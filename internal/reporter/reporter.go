package reporter

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/alexkarsten/dehydrate/pkg/models"
)

type Reporter struct {
	cfg       *models.Config
	outputDir string
}

func New(cfg *models.Config) *Reporter {
	return &Reporter{
		cfg:       cfg,
		outputDir: ".dehydrate",
	}
}

func (r *Reporter) Generate(result *models.RefactorResult) error {
	if err := os.MkdirAll(r.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	report := &models.Report{
		SessionID:     result.SessionID,
		GeneratedAt:   time.Now(),
		LOCBefore:     result.MetricsBefore.LinesOfCode,
		LOCAfter:      result.MetricsAfter.LinesOfCode,
		LOCReduced:    result.MetricsBefore.LinesOfCode - result.MetricsAfter.LinesOfCode,
		FilesModified: r.extractModifiedFiles(result.Changes),
		MetricsDelta: models.MetricsDelta{
			CyclomaticComplexityDelta: result.MetricsBefore.CyclomaticComplexity - result.MetricsAfter.CyclomaticComplexity,
			CognitiveComplexityDelta:  result.MetricsBefore.CognitiveComplexity - result.MetricsAfter.CognitiveComplexity,
			MaintainabilityIndexDelta: result.MetricsAfter.MaintainabilityIndex - result.MetricsBefore.MaintainabilityIndex,
		},
	}

	content := r.formatMarkdown(report, result)

	filename := fmt.Sprintf("dehydrate-report-%s.md", result.SessionID)
	path := filepath.Join(r.outputDir, filename)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write report: %w", err)
	}

	fmt.Printf("Report generated: %s\n", path)
	return nil
}

func (r *Reporter) Load(sessionID string) error {
	if sessionID == "" {
		entries, err := os.ReadDir(r.outputDir)
		if err != nil {
			return fmt.Errorf("no reports found")
		}

		var latest string
		var latestTime time.Time
		for _, entry := range entries {
			if strings.HasPrefix(entry.Name(), "dehydrate-report-") && strings.HasSuffix(entry.Name(), ".md") {
				info, err := entry.Info()
				if err != nil {
					continue
				}
				if info.ModTime().After(latestTime) {
					latestTime = info.ModTime()
					latest = entry.Name()
				}
			}
		}

		if latest == "" {
			return fmt.Errorf("no reports found")
		}

		sessionID = strings.TrimPrefix(latest, "dehydrate-report-")
		sessionID = strings.TrimSuffix(sessionID, ".md")
	}

	path := filepath.Join(r.outputDir, fmt.Sprintf("dehydrate-report-%s.md", sessionID))
	content, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read report: %w", err)
	}

	fmt.Println(string(content))
	return nil
}

func (r *Reporter) formatMarkdown(report *models.Report, result *models.RefactorResult) string {
	var sb strings.Builder

	sb.WriteString("# dehydrator Compression Report\n\n")
	sb.WriteString(fmt.Sprintf("**Session ID:** %s\n\n", report.SessionID))
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n\n", report.GeneratedAt.Format(time.RFC3339)))

	sb.WriteString("## Summary\n\n")
	sb.WriteString(fmt.Sprintf("| Metric | Before | After | Delta |\n"))
	sb.WriteString(fmt.Sprintf("|--------|--------|-------|-------|\n"))
	sb.WriteString(fmt.Sprintf("| Lines of Code | %d | %d | **%d** |\n",
		report.LOCBefore, report.LOCAfter, report.LOCReduced))
	sb.WriteString(fmt.Sprintf("| Cyclomatic Complexity | %d | %d | %d |\n",
		result.MetricsBefore.CyclomaticComplexity, result.MetricsAfter.CyclomaticComplexity,
		report.MetricsDelta.CyclomaticComplexityDelta))
	sb.WriteString(fmt.Sprintf("| Cognitive Complexity | %d | %d | %d |\n",
		result.MetricsBefore.CognitiveComplexity, result.MetricsAfter.CognitiveComplexity,
		report.MetricsDelta.CognitiveComplexityDelta))
	sb.WriteString(fmt.Sprintf("| Maintainability Index | %.2f | %.2f | %.2f |\n\n",
		result.MetricsBefore.MaintainabilityIndex, result.MetricsAfter.MaintainabilityIndex,
		report.MetricsDelta.MaintainabilityIndexDelta))

	sb.WriteString("## Files Modified\n\n")
	for _, file := range report.FilesModified {
		sb.WriteString(fmt.Sprintf("- `%s`\n", file))
	}
	sb.WriteString("\n")

	if len(report.PatternsApplied) > 0 {
		sb.WriteString("## Patterns Applied\n\n")
		for _, p := range report.PatternsApplied {
			sb.WriteString(fmt.Sprintf("### %s\n\n", p.Pattern))
			sb.WriteString(fmt.Sprintf("%s\n\n", p.Description))
			sb.WriteString("Files:\n")
			for _, f := range p.Files {
				sb.WriteString(fmt.Sprintf("- `%s`\n", f))
			}
			sb.WriteString("\n")
		}
	}

	sb.WriteString("## Changes\n\n")
	for i, change := range result.Changes {
		sb.WriteString(fmt.Sprintf("### %d. %s\n\n", i+1, change.Path))
		sb.WriteString(fmt.Sprintf("%s\n\n", change.Description))
		sb.WriteString("```diff\n")
		sb.WriteString(r.generateDiff(change.Original, change.Modified))
		sb.WriteString("\n```\n\n")
	}

	sb.WriteString("---\n")
	sb.WriteString("*Generated by dehydrator - Semantic Code Compression Engine*\n")

	return sb.String()
}

func (r *Reporter) extractModifiedFiles(changes []models.FileChange) []string {
	seen := make(map[string]bool)
	var files []string
	for _, change := range changes {
		if !seen[change.Path] {
			seen[change.Path] = true
			files = append(files, change.Path)
		}
	}
	return files
}

func (r *Reporter) generateDiff(original, modified string) string {
	origLines := strings.Split(original, "\n")
	modLines := strings.Split(modified, "\n")

	var diff strings.Builder

	maxLen := len(origLines)
	if len(modLines) > maxLen {
		maxLen = len(modLines)
	}

	for i := 0; i < maxLen; i++ {
		if i < len(origLines) && i < len(modLines) {
			if origLines[i] == modLines[i] {
				diff.WriteString("  " + origLines[i] + "\n")
			} else {
				diff.WriteString("- " + origLines[i] + "\n")
				diff.WriteString("+ " + modLines[i] + "\n")
			}
		} else if i < len(origLines) {
			diff.WriteString("- " + origLines[i] + "\n")
		} else {
			diff.WriteString("+ " + modLines[i] + "\n")
		}
	}

	return diff.String()
}
