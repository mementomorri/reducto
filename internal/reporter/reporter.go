package reporter

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/alexkarsten/reducto/pkg/models"
)

type Reporter struct {
	cfg       *models.Config
	outputDir string
}

func New(cfg *models.Config) *Reporter {
	return &Reporter{
		cfg:       cfg,
		outputDir: ".reducto",
	}
}

func (r *Reporter) Generate(result *models.RefactorResult) error {
	if err := os.MkdirAll(r.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	report := &models.Report{
		SessionID:     result.SessionID,
		GeneratedAt:   time.Now(),
		LOCBefore:     result.MetricsBefore.LinesOfCode,
		LOCAfter:      result.MetricsAfter.LinesOfCode,
		LOCReduced:    result.MetricsBefore.LinesOfCode - result.MetricsAfter.LinesOfCode,
		FilesModified: r.extractModifiedFiles(result.Changes),
		MetricsDelta: models.MetricsDelta{
			CyclomaticComplexityDelta: result.MetricsBefore.CyclomaticComplexity - result.MetricsAfter.CyclomaticComplexity,
			CognitiveComplexityDelta:  result.MetricsBefore.CognitiveComplexity - result.MetricsAfter.CognitiveComplexity,
			MaintainabilityIndexDelta: result.MetricsAfter.MaintainabilityIndex - result.MetricsBefore.MaintainabilityIndex,
		},
	}

	content := r.formatMarkdown(report, result)

	filename := fmt.Sprintf("reducto-report-%s.md", result.SessionID)
	path := filepath.Join(r.outputDir, filename)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write report: %w", err)
	}

	fmt.Printf("Report generated: %s\n", path)
	return nil
}

type BaselineResult struct {
	TotalFiles   int
	TotalSymbols int
	Hotspots     []ComplexityHotspot
}

type ComplexityHotspot struct {
	File                 string
	Line                 int
	Symbol               string
	CyclomaticComplexity int
	CognitiveComplexity  int
}

func (r *Reporter) GenerateBaseline(result *BaselineResult) error {
	if err := os.MkdirAll(r.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	sessionID := fmt.Sprintf("baseline-%d", time.Now().Unix())
	content := r.formatBaselineMarkdown(sessionID, result)

	filename := fmt.Sprintf("reducto-baseline-%s.md", time.Now().Format("20060102-150405"))
	path := filepath.Join(r.outputDir, filename)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write baseline report: %w", err)
	}

	fmt.Printf("Baseline report generated: %s\n", path)
	return nil
}

func (r *Reporter) formatBaselineMarkdown(sessionID string, result *BaselineResult) string {
	var sb strings.Builder

	sb.WriteString("# reducto Baseline Analysis Report\n\n")
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n\n", time.Now().Format(time.RFC3339)))

	sb.WriteString("## Summary\n\n")
	sb.WriteString(fmt.Sprintf("| Metric | Value |\n"))
	sb.WriteString(fmt.Sprintf("|--------|-------|\n"))
	sb.WriteString(fmt.Sprintf("| Total Files | %d |\n", result.TotalFiles))
	sb.WriteString(fmt.Sprintf("| Total Symbols | %d |\n", result.TotalSymbols))
	sb.WriteString(fmt.Sprintf("| Complexity Hotspots | %d |\n\n", len(result.Hotspots)))

	if len(result.Hotspots) > 0 {
		sb.WriteString("## Complexity Hotspots\n\n")
		sb.WriteString("| File | Line | Symbol | Cyclomatic | Cognitive |\n")
		sb.WriteString("|------|------|--------|------------|-----------|\n")
		for _, hs := range result.Hotspots {
			sb.WriteString(fmt.Sprintf("| %s | %d | %s | %d | %d |\n",
				hs.File, hs.Line, hs.Symbol, hs.CyclomaticComplexity, hs.CognitiveComplexity))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("---\n")
	sb.WriteString("*Generated by reducto - Semantic Code Compression Engine*\n")

	return sb.String()
}

func (r *Reporter) Load(sessionID string) error {
	if sessionID == "" {
		entries, err := os.ReadDir(r.outputDir)
		if err != nil {
			return fmt.Errorf("no reports found")
		}

		var latest string
		var latestTime time.Time
		for _, entry := range entries {
			if strings.HasPrefix(entry.Name(), "reducto-report-") && strings.HasSuffix(entry.Name(), ".md") {
				info, err := entry.Info()
				if err != nil {
					continue
				}
				if info.ModTime().After(latestTime) {
					latestTime = info.ModTime()
					latest = entry.Name()
				}
			}
		}

		if latest == "" {
			return fmt.Errorf("no reports found")
		}

		sessionID = strings.TrimPrefix(latest, "reducto-report-")
		sessionID = strings.TrimSuffix(sessionID, ".md")
	}

	path := filepath.Join(r.outputDir, fmt.Sprintf("reducto-report-%s.md", sessionID))
	content, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read report: %w", err)
	}

	fmt.Println(string(content))
	return nil
}

func (r *Reporter) formatMarkdown(report *models.Report, result *models.RefactorResult) string {
	var sb strings.Builder

	sb.WriteString("# reducto Compression Report\n\n")
	sb.WriteString(fmt.Sprintf("**Session ID:** %s\n\n", report.SessionID))
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n\n", report.GeneratedAt.Format(time.RFC3339)))

	sb.WriteString("## Summary\n\n")
	sb.WriteString(fmt.Sprintf("| Metric | Before | After | Delta |\n"))
	sb.WriteString(fmt.Sprintf("|--------|--------|-------|-------|\n"))
	sb.WriteString(fmt.Sprintf("| Lines of Code | %d | %d | **%d** |\n",
		report.LOCBefore, report.LOCAfter, report.LOCReduced))
	sb.WriteString(fmt.Sprintf("| Cyclomatic Complexity | %d | %d | %d |\n",
		result.MetricsBefore.CyclomaticComplexity, result.MetricsAfter.CyclomaticComplexity,
		report.MetricsDelta.CyclomaticComplexityDelta))
	sb.WriteString(fmt.Sprintf("| Cognitive Complexity | %d | %d | %d |\n",
		result.MetricsBefore.CognitiveComplexity, result.MetricsAfter.CognitiveComplexity,
		report.MetricsDelta.CognitiveComplexityDelta))
	sb.WriteString(fmt.Sprintf("| Maintainability Index | %.2f | %.2f | %.2f |\n\n",
		result.MetricsBefore.MaintainabilityIndex, result.MetricsAfter.MaintainabilityIndex,
		report.MetricsDelta.MaintainabilityIndexDelta))

	sb.WriteString("## Files Modified\n\n")
	for _, file := range report.FilesModified {
		sb.WriteString(fmt.Sprintf("- `%s`\n", file))
	}
	sb.WriteString("\n")

	if len(report.PatternsApplied) > 0 {
		sb.WriteString("## Patterns Applied\n\n")
		for _, p := range report.PatternsApplied {
			sb.WriteString(fmt.Sprintf("### %s\n\n", p.Pattern))
			sb.WriteString(fmt.Sprintf("%s\n\n", p.Description))
			sb.WriteString("Files:\n")
			for _, f := range p.Files {
				sb.WriteString(fmt.Sprintf("- `%s`\n", f))
			}
			sb.WriteString("\n")
		}
	}

	sb.WriteString("## Changes\n\n")
	for i, change := range result.Changes {
		sb.WriteString(fmt.Sprintf("### %d. %s\n\n", i+1, change.Path))
		sb.WriteString(fmt.Sprintf("%s\n\n", change.Description))
		sb.WriteString("```diff\n")
		sb.WriteString(r.generateDiff(change.Original, change.Modified))
		sb.WriteString("\n```\n\n")
	}

	sb.WriteString("---\n")
	sb.WriteString("*Generated by reducto - Semantic Code Compression Engine*\n")

	return sb.String()
}

func (r *Reporter) extractModifiedFiles(changes []models.FileChange) []string {
	seen := make(map[string]bool)
	var files []string
	for _, change := range changes {
		if !seen[change.Path] {
			seen[change.Path] = true
			files = append(files, change.Path)
		}
	}
	return files
}

func (r *Reporter) generateDiff(original, modified string) string {
	origLines := strings.Split(original, "\n")
	modLines := strings.Split(modified, "\n")

	var diff strings.Builder

	maxLen := len(origLines)
	if len(modLines) > maxLen {
		maxLen = len(modLines)
	}

	for i := 0; i < maxLen; i++ {
		if i < len(origLines) && i < len(modLines) {
			if origLines[i] == modLines[i] {
				diff.WriteString("  " + origLines[i] + "\n")
			} else {
				diff.WriteString("- " + origLines[i] + "\n")
				diff.WriteString("+ " + modLines[i] + "\n")
			}
		} else if i < len(origLines) {
			diff.WriteString("- " + origLines[i] + "\n")
		} else {
			diff.WriteString("+ " + modLines[i] + "\n")
		}
	}

	return diff.String()
}

func (r *Reporter) GenerateDryRun(plan *models.RefactorPlan, command, path string) error {
	if err := os.MkdirAll(r.outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	content := r.formatDryRunMarkdown(plan, command, path)

	filename := fmt.Sprintf("reducto-dryrun-%s.md", plan.SessionID)
	reportPath := filepath.Join(r.outputDir, filename)

	if err := os.WriteFile(reportPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write dry-run report: %w", err)
	}

	fmt.Println(content)
	fmt.Printf("\nDry-run report saved to: %s\n", reportPath)
	return nil
}

func (r *Reporter) formatDryRunMarkdown(plan *models.RefactorPlan, command, path string) string {
	var sb strings.Builder

	sb.WriteString("# reducto Dry-Run Report\n\n")
	sb.WriteString(fmt.Sprintf("**Generated:** %s\n", time.Now().Format(time.RFC3339)))
	sb.WriteString(fmt.Sprintf("**Command:** %s\n", command))
	sb.WriteString(fmt.Sprintf("**Path:** %s\n", path))
	sb.WriteString(fmt.Sprintf("**Session ID:** %s\n\n", plan.SessionID))

	sb.WriteString("> **DRY RUN MODE** - No changes will be applied.\n")
	sb.WriteString("> Run with `--yes` to apply these changes.\n\n")

	sb.WriteString("## Summary\n\n")
	estimatedLOC := r.estimateLOCChange(plan.Changes)
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Changes proposed | %d |\n", len(plan.Changes)))
	sb.WriteString(fmt.Sprintf("| Files affected | %d |\n", len(r.extractModifiedFiles(plan.Changes))))
	sb.WriteString(fmt.Sprintf("| Estimated LOC change | %s |\n\n", estimatedLOC))

	if len(plan.Changes) == 0 {
		sb.WriteString("No changes proposed.\n\n")
	} else {
		sb.WriteString("## Proposed Changes\n\n")
		for i, change := range plan.Changes {
			sb.WriteString(fmt.Sprintf("### %d. `%s`\n\n", i+1, change.Path))
			if change.Description != "" {
				sb.WriteString(fmt.Sprintf("%s\n\n", change.Description))
			}
			sb.WriteString("```diff\n")
			if change.Original == "" {
				sb.WriteString("--- /dev/null\n")
				sb.WriteString(fmt.Sprintf("+++ b/%s\n", change.Path))
				lines := strings.Split(change.Modified, "\n")
				for _, line := range lines {
					sb.WriteString(fmt.Sprintf("+%s\n", line))
				}
			} else if change.Modified == "" {
				sb.WriteString(fmt.Sprintf("--- a/%s\n", change.Path))
				sb.WriteString("+++ /dev/null\n")
				lines := strings.Split(change.Original, "\n")
				for _, line := range lines {
					sb.WriteString(fmt.Sprintf("-%s\n", line))
				}
			} else {
				sb.WriteString(r.generateDiff(change.Original, change.Modified))
			}
			sb.WriteString("```\n\n")
		}
	}

	sb.WriteString("---\n")
	sb.WriteString("*Generated by reducto - Semantic Code Compression Engine*\n")

	return sb.String()
}

func (r *Reporter) estimateLOCChange(changes []models.FileChange) string {
	var added, removed int
	for _, change := range changes {
		if change.Original == "" && change.Modified != "" {
			added += len(strings.Split(change.Modified, "\n"))
		} else if change.Original != "" && change.Modified == "" {
			removed += len(strings.Split(change.Original, "\n"))
		} else {
			origLines := len(strings.Split(change.Original, "\n"))
			modLines := len(strings.Split(change.Modified, "\n"))
			if modLines > origLines {
				added += modLines - origLines
			} else {
				removed += origLines - modLines
			}
		}
	}
	if added == 0 && removed == 0 {
		return "0"
	}
	if added > 0 && removed > 0 {
		return fmt.Sprintf("+%d / -%d", added, removed)
	}
	if added > 0 {
		return fmt.Sprintf("+%d", added)
	}
	return fmt.Sprintf("-%d", removed)
}
